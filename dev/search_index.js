var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [SearchModels]","category":"page"},{"location":"api/#SearchModels.SearchParams","page":"API","title":"SearchModels.SearchParams","text":"SearchParams(;\n    maxpopulation::Int = 32\n    bsize::Int = 16\n    mutbsize::Int = 8\n    crossbsize::Int = 8\n    maxiters::Int = 300\n    verbose::Bool = true\n)\n\nreates a mutable list of search parameters, it can be changed online via inspect_population.\n\nmaxpopulation: the maximum number of configurations to be kept at each iteration (based on its minimum error)\nbsize: number of best items to be used for mutation and crossing procedures\nmutbsize: number of new configurations per iteration from a mutation procedure\ncrossbsize: number of new configurations per iteration from a crossing procedure\nmaxiters: maximum iterations of the search procedure\nverbose: controls if the verbosity of the search iterations\n\n\n\n\n\n","category":"type"},{"location":"api/#SearchModels.change-Tuple{Any,Any}","page":"API","title":"SearchModels.change","text":"change(x, choices; p1=0.5)\n\nWith prob p1 x is changed by some element in choices. Please note that if x in choices then the actual p1 is modified.\n\n\n\n\n\n","category":"method"},{"location":"api/#SearchModels.combine","page":"API","title":"SearchModels.combine","text":"combine(space::AbstractSolutionSpace, c1, c2)\ncombine(c1, c2)\n\nCombines two configurations into a single configuration. The three argument functions defaults to two argument function.\n\n\n\n\n\n","category":"function"},{"location":"api/#SearchModels.combine_select-Union{Tuple{T}, Tuple{T,AbstractArray{T,1} where T}} where T","page":"API","title":"SearchModels.combine_select","text":"combine_select(a, L::AbstractVector)\n\nCombines a configuration with some compatible configuation in the given list of pairs (config => score), The a config is always at the end of L and also L is always shuffled. If you are in doubt, use the higher level interface combine(c1, c2).\n\n\n\n\n\n","category":"method"},{"location":"api/#SearchModels.compatible_space-Tuple{AbstractArray{T,1} where T,Any}","page":"API","title":"SearchModels.compatible_space","text":"compatible_space(space::AbstractVector, c)\n\nSelects the compatible space for configuration c\n\n\n\n\n\n","category":"method"},{"location":"api/#SearchModels.config_type-Union{Tuple{T}, Tuple{T}} where T","page":"API","title":"SearchModels.config_type","text":"config_type(::T)\n\nConfig type identifier, it may or not be a type\n\n\n\n\n\n","category":"method"},{"location":"api/#SearchModels.evaluate_queue-Tuple{Function,Any,Any,Any,Any}","page":"API","title":"SearchModels.evaluate_queue","text":"evaluate_queue(errfun::Function, evalqueue, population, parallel, tmp)\n\nEvaluates queue of using errfun; the resulting config => performances are stored in config_and_perf\n\n\n\n\n\n","category":"method"},{"location":"api/#SearchModels.mutate-Tuple{AbstractArray{T,1} where T,Any,Any}","page":"API","title":"SearchModels.mutate","text":"mutate(space::AbstractSolutionSpace, c, iter)\nmutate(space::AbstractVector, c, iter)\n\nMutates configuration. If space is a list of spaces, then the proper space is determined.\n\n\n\n\n\n","category":"method"},{"location":"api/#SearchModels.queue_config!-NTuple{4,Any}","page":"API","title":"SearchModels.queue_config!","text":"queue_config!(accept_config, conf, evalqueue, observed)\n\nPushes conf into the evaluation queue. It checks if was already observed and if it is accepted by the accept_config predicate.\n\n\n\n\n\n","category":"method"},{"location":"api/#SearchModels.scale-Union{Tuple{T}, Tuple{T}} where T<:AbstractFloat","page":"API","title":"SearchModels.scale","text":"scale(x, s=1.1; p1=0.5, p2=0.5, lower=typemin(T), upper=typemax(T))::T\n\nWith probability p1 xis scaled bys; ifxis going to be scaled, then with probabilityp2x` is growth (or reduced otherwise). Minimum and maximum values can be specified.\n\n\n\n\n\n","category":"method"},{"location":"api/#SearchModels.search_models","page":"API","title":"SearchModels.search_models","text":"search_models(\n    errfun::Function,  # error function, it can be used with `do conf ... end` block\n    space::AbstractSolutionSpace,\n    initialpopulation=32,\n    params::SearchParams=SearchParams();\n    geterr::Function=identity,\n    accept_config::Function=config->true,\n    inspect_population::Function=(space, params, population) -> nothing,\n    sort_by_best::Function=sort_by_best,\n    convergence::Function=(curr, prev) -> abs(last(curr), last(prev)) < 0.001,\n    parallel=:none, # :none, :threads, :distributed\n)\n\nExplores the search space trying to minimize the given error function. The procedure consists on an iterative stochastic method based on an evolutionary algorithm. It is starts with initialpopulation configurations, evaluate them mutate and cross them; it selects at most maxpopulation configurations at any iteration (best ones).\n\nerrfun: the function to minimize (receives the configuration as argument)\nspace: Search space definition\nparams: search parameters\ngeterr a function to compute or fetch the cost (a single floating point) on the output of errfun\ninitialpopulation: initial number of configurations to conform the population, or an initial list of configurations\naccept_config: an alternative way to deny some configuration to be evaluated (receives the configuration as argument)\nsort_by_best: the default minimizes the error function retrieved by geterr \nconvergence: tests current best and previous best for search convergence\ninspect_population: observes the population after evaluating a beam of solutions\nparallel: controls if the search is made with some kind of parallel strategy (only used for evaluation errors). Valid values are:\n:none: there is no parallelization, the default value\n:threads: evaluates error functions using threads\n:distributed: evaluates error functions using a distributed environment (using the available workers)\n\n\n\n\n\n","category":"function"},{"location":"api/#SearchModels.translate-Union{Tuple{T}, Tuple{T}} where T<:Real","page":"API","title":"SearchModels.translate","text":"translate(x::T; s=2, p1=0.5, p2=0.5, lower=typemin(T), upper=typemax(T)) where {T<:Real}\n\nWith probability p1 x is modified; if x is modified, then with probability p2 returns x+s or x-s otherwise. Minimum and maximum values can be specified.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = SearchModels","category":"page"},{"location":"#SearchModels","page":"Home","title":"SearchModels","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Provides a generic method for minimizing model errors using stochastic search, which is often used whenever the problem has no concept of derivative. This kind of problems rely on large exploration of combinatorial spaces based on error function.","category":"page"},{"location":"","page":"Home","title":"Home","text":"SearchModels rely on basic exploration functions that can be specified for many applications.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Due to its generic specification, other kind of optimization problems can be also solved, however, it could be easier and better to use other approaches.","category":"page"},{"location":"#Using-SearchModels","page":"Home","title":"Using SearchModels","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The code idea is to describe a configuration space (solution space) for some model, that controls how the space is explored. The model is evaluated using an error function, and the resulting errors are used to navigate the solution space.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For this purpose SearchModels expect that some methods to work. As described below.","category":"page"},{"location":"","page":"Home","title":"Home","text":"All configuration spaces should be an specialization of the abstract type AbstractSolutionSpace.\nrand(space::AbstractSolutionSpace): Creates a random configuration sampling the given space\ncombine(a, L::AbstractVector): Combines the a solution 'a' with the list of solutions L (an array of pairs solution => error). By default it samples L for a compatible solution with  a and calls combine(c1, c2). A compatible solution is defined to share the same config_type(a).\ncombine(c1, c2): Combines two configurations into a single one; most applications should override this method.\nmutate(space::AbstractSolutionSpace, config, iter::Integer): Mutates config (a small perturbation, commonly following the space description). The iter value contains the iteration counter, it could be used to adjust the perturbation level.\nmutate(space::AbstractVector, c, iter): Dispatch of the applicable mutation function whenever space defines heterogeneous types.\nconfig_type(::T) describes the type of T, it defaults to Base.typename(T) but it could be any other value that makes sense for the application.\neltype(::AbstractSolutionSpace): Defines what kind of objects are expected to be sampled from the solution space; it requires an specialization of eltype (i.e., to add import Base: eltype).","category":"page"},{"location":"","page":"Home","title":"Home","text":"For complex enough configurations (solutions) you may need to define specialize hash, and isequal since the search process uses it to keep a track of the evalauted configurations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Most of the work is made in search_models function. ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"CurrentModule = SearchModels","category":"page"},{"location":"example/#Example:-Solving-a-polynomial-regresión","page":"Example","title":"Example: Solving a polynomial regresión","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"This is a toy example that help us to select and fit a polynomial model for an input data. You may realize that threre are better ways to solve this example, but here we want to show how to use it succinctly. SearchModels is indended on problems without a definition of derivatives, and in particular, on solving model selection for different kinds of structures.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"The approach of SearchModels consists on modeling our solution space defining a struct type and three related methods: rand, combine, and mutate. We also may need to define config_type and eltype. In particular, config_type needs to be defined here to put the type as the polynomial's degree to be able to distinguish among different degrees. The eltype should be defined to use concrete types internally on several queues.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"using SearchModels, Random\nimport SearchModels: combine, mutate, config_type\n\nRandom.seed!(0) # fixing seed\n\nstruct PolyModelSpace <: AbstractSolutionSpace\n    degree\nend\n\nconst PolyModel = Vector{Float64}\n\nBase.eltype(::PolyModelSpace) = PolyModel\nconfig_type(c::PolyModel) = length(c)  # polynomial degree\n","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"The precise definitions of the exploration methods may differ, but they are used to randomly sample the solution space, combine two configurations into a single one, and mutate one based (or not) on the space definition. Please notice that a polynomial is simply represented by its coefficients.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"function Base.rand(space::PolyModelSpace)\n    randn(rand(space.degree) + 1)\nend\n\nfunction combine(a::PolyModel, b::PolyModel)\n    [(a[i] + b[i]) / 2.0 for i in eachindex(a)]\nend\n\nfunction mutate(space::PolyModelSpace, c::PolyModel, iter)\n    step = 1.0 + 1 / (1 + iter)\n    [SearchModels.scale(c[i], s=step) for i in eachindex(c)]\nend\n","category":"page"},{"location":"example/#Evaluation-of-a-polynomial","page":"Example","title":"Evaluation of a polynomial","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"For illustrative purposes, we need to generate synthetic example, firstly, we need to define how to evaluate a polynomial.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"function poly(coeff, x)::Float64\n    s = coeff[1]\n    @inbounds @simd for i in 2:length(coeff)\n        m = coeff[i]\n        s += coeff[i] * x^(i-1)\n    end\n\n    s\nend","category":"page"},{"location":"example/#A-synthetic-example","page":"Example","title":"A synthetic example","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"We will create a dataset with a random polynomial, here we also define the error function","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"function create_model_1(n)\n    X = collect(-10:0.1:10)\n    coeff = rand(n + 1)\n    X, [poly(coeff, x) for x in X], coeff\nend\n\n\nX, y, coeff__ = create_model_1(4)\n\nfunction error_function(c)::Float64\n    s = zero(Float64)\n    @inbounds @simd for i in eachindex(X)\n        m = poly(c, X[i]) - y[i]\n        s += m * m\n    end\n\n    s / length(X)\nend","category":"page"},{"location":"example/#Search-process","page":"Example","title":"Search process","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"Even when our target polynomial's degree is 4, we allow polynomials of different degrees, the search procedure must minimize the error and this includes selecting the best degree and its coefficients.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"space = PolyModelSpace(2:5)\nB = search_models(space, error_function, 300,\n    maxpopulation=64,\n    bsize=64,\n    mutbsize=32,\n    crossbsize=32,\n    tol=0.0,\n    maxiters=300,\n    verbose=true\n)\n\nlength(B)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Here, we indicte that the search process must error_function as error (it receives a configuration), starts sampling 300 random solutions generated with rand. Note that the search will store atmost maxpopulation individuals, those achieving the lower errors. If not specified maxpopulation is set to the number of initial population. The iterative process consists on explore the solution space using combination and mutation, using top bsize items. The combination and mutation generate crossbsize and mutbisize new configurations at each iteration (using top bsize configurations). The search is stoppend when two iterations do not improve atleast by tol the error (of the worst error in the entire population) or the number of maximum allowed iterations are reached. ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"println(stderr, \"target polynomial: \", coeff__)\nfor b in B[1:10]\n    println(stderr, \"score=$(b.second), coeffs: $(b.first)\")\nend","category":"page"}]
}
